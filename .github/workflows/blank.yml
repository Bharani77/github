name: Expose SSH via Wetty + LocalTunnel
on:
  workflow_dispatch:
    inputs:
      duration:
        description: 'Duration to keep tunnel alive (minutes)'
        required: true
        default: '60'
        type: string
      password:
        description: 'Password for SSH user'
        required: true
        type: string

jobs:
  expose-ssh-web:
    runs-on: ubuntu-latest
    timeout-minutes: 120  # Maximum runtime protection
    steps:
      - name: Install required packages
        run: |
          sudo apt-get update
          sudo apt-get install -y openssh-server nodejs npm
          sudo systemctl start ssh
          sudo systemctl enable ssh

      - name: Create new user
        run: |
          sudo useradd -m -s /bin/bash sshuser
          echo "sshuser:${{ github.event.inputs.password }}" | sudo chpasswd
          # Add user to sudo group if needed
          # sudo usermod -aG sudo sshuser

      - name: Install Wetty and LocalTunnel
        run: |
          sudo npm install -g wetty localtunnel

      - name: Start Wetty server
        run: |
          # Start Wetty with proper configuration
          wetty --port 3000 --host 0.0.0.0 --ssh-host localhost --ssh-user sshuser --title "GitHub Actions SSH" > wetty.log 2>&1 &
          sleep 5
          
          # Check if Wetty is running
          if pgrep -f wetty > /dev/null; then
            echo "‚úÖ Wetty server started successfully on port 3000"
            # Test local connection
            curl -s http://localhost:3000 > /dev/null && echo "‚úÖ Wetty responding locally" || echo "‚ö†Ô∏è  Wetty not responding locally"
          else
            echo "‚ùå Failed to start Wetty server"
            cat wetty.log
            exit 1
          fi

      - name: Start LocalTunnel and capture URL
        run: |
          # Start LocalTunnel without fixed subdomain to avoid conflicts
          lt --port 3000 > lt.log 2>&1 &
          sleep 10
          
          # Extract and display the URL
          TUNNEL_URL=$(grep -o 'https://.*\.loca\.lt' lt.log | head -1)
          if [ -n "$TUNNEL_URL" ]; then
            echo "üåê SSH Web Terminal is available at: $TUNNEL_URL"
            echo "üåê Direct terminal access: $TUNNEL_URL/wetty"
            echo "üë§ Username: sshuser"
            echo "üîë Password: [as provided in workflow input]"
            echo "‚è∞ Will stay alive for ${{ github.event.inputs.duration }} minutes"
            echo ""
            echo "üìã IMPORTANT: To bypass LocalTunnel's reminder page, use ONE of these methods:"
            echo "   Method 1: Add header 'bypass-tunnel-reminder: true' to your browser requests"
            echo "   Method 2: Set a custom User-Agent like 'MyCustomAgent/1.0'"
            echo "   Method 3: Use curl: curl -H 'bypass-tunnel-reminder: true' $TUNNEL_URL"
            
            # Also write to step summary for easy access
            echo "## üöÄ SSH Web Terminal Ready" >> $GITHUB_STEP_SUMMARY
            echo "**Main URL:** $TUNNEL_URL" >> $GITHUB_STEP_SUMMARY
            echo "**Terminal URL:** $TUNNEL_URL/wetty" >> $GITHUB_STEP_SUMMARY
            echo "**Username:** sshuser" >> $GITHUB_STEP_SUMMARY
            echo "**Duration:** ${{ github.event.inputs.duration }} minutes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîß Bypass LocalTunnel Reminder:" >> $GITHUB_STEP_SUMMARY
            echo "- Add header: \`bypass-tunnel-reminder: true\`" >> $GITHUB_STEP_SUMMARY
            echo "- Or use custom User-Agent: \`MyCustomAgent/1.0\`" >> $GITHUB_STEP_SUMMARY
            echo "- Browser extensions like ModHeader can help set custom headers" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Failed to get LocalTunnel URL"
            cat lt.log
            exit 1
          fi

      - name: Keep tunnel alive
        run: |
          echo "Keeping tunnel alive for ${{ github.event.inputs.duration }} minutes..."
          sleep $((${{ github.event.inputs.duration }} * 60))
          echo "Tunnel session ended."

      - name: Cleanup (runs even if job is cancelled)
        if: always()
        run: |
          echo "Cleaning up processes..."
          pkill -f wetty || true
          pkill -f localtunnel || true
          sudo userdel -r sshuser || true
